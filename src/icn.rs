use bevy::input::mouse::MouseButtonInput;
use bevy::prelude::*;
use bevy::sprite::MaterialMesh2dBundle;
use bevy::{asset::LoadState, prelude::*, render::render_resource::*};
use bevy_mod_raycast::*;
use std::fs::File;
use std::io::BufReader;
use std::io::{Read, Seek, SeekFrom};
use std::prelude::*;

pub struct IcnPlugin;

impl Plugin for IcnPlugin {
  fn build(&self, app: &mut App) {
    app
      // .insert_resource(ClearColor(Color::rgb(255., 255., 255.)))
      .add_startup_system(setup);
  }
}

fn setup(
  mut commands: Commands,
  mut images: ResMut<Assets<Image>>,
  mut meshes: ResMut<Assets<Mesh>>,
  mut materials: ResMut<Assets<ColorMaterial>>,
) {
  let (header, buf) = parse_icn().unwrap();

  commands.spawn_bundle(Camera2dBundle {
    transform: Transform {
      scale: Vec3::new(1. / 3., 1. / 3., 1.),
      ..default()
    },
    ..default()
  });

  info!("{:?}", header);

  let mut image = Image::new(
    Extent3d {
      width: header.width as u32,
      height: header.height as u32,
      depth_or_array_layers: 1,
    },
    TextureDimension::D2,
    buf,
    TextureFormat::Rgba8UnormSrgb,
  );
  image.texture_descriptor.usage =
    TextureUsages::COPY_DST | TextureUsages::STORAGE_BINDING | TextureUsages::TEXTURE_BINDING;

  let image_handle = images.add(image);

  commands.spawn().insert_bundle(MaterialMesh2dBundle {
    mesh: meshes
      .add(Mesh::from(shape::Quad {
        size: Vec2::new(header.width as f32, header.height as f32),
        flip: false,
      }))
      .into(),
    material: materials.add(ColorMaterial {
      color: Color::rgba(0., 0., 0., 0.0),
      ..default()
    }),
    ..default()
  });

  commands.spawn().insert_bundle(MaterialMesh2dBundle {
    mesh: meshes
      .add(Mesh::from(shape::Quad {
        size: Vec2::new(header.width as f32, header.height as f32),
        flip: false,
      }))
      .into(),
    material: materials.add(ColorMaterial {
      texture: Some(image_handle),
      ..default()
    }),
    ..default()
  });
}

#[derive(Debug, Clone, Copy)]
struct ICNHeader {
  offset_x: i16,
  offset_y: i16,
  width: u16,
  height: u16,
  sprite_type: u8,
  offset: u32,
}

fn parse_icn() -> Option<(ICNHeader, Vec<u8>)> {
  let mut f = File::open("./extract/ZOMBIE.ICN").unwrap();
  let mut reader = BufReader::new(f.by_ref());
  let mut buf = Vec::new();

  reader.read_to_end(&mut buf).unwrap();

  let n = le_to_u16(&buf[..2]);
  let size = le_to_u32(&buf[2..6]);
  println!("Sprite count: {}; Total size: {}", n, size);

  let mut headers = Vec::new();
  let palette = init_pal();

  for x in 0..n {
    let h = &buf[(x * 13 + 6) as usize..(x * 13 + 13 + 6) as usize];
    headers.push(ICNHeader {
      offset_x: le_to_i16(&h[..2]),
      offset_y: le_to_i16(&h[2..4]),
      width: le_to_u16(&h[4..6]),
      height: le_to_u16(&h[6..8]),
      sprite_type: h[8],
      offset: le_to_u32(&h[9..13]),
    });
  }

  for (header_i, header) in headers[1..].iter().enumerate() {
    let fref = f.by_ref();

    println!("{}/{}", header_i, headers.len());

    let mut x = 0;
    let mut y = 0;

    // let mut f = File::create(format!("./boar/{}.hex", header_i)).unwrap();

    let mut img_data = Vec::with_capacity((header.width * header.height * 4) as usize);

    let insert_empty = || [0, 0, 0, 0];
    let insert_color = |c: Color| [c.r() as u8, c.g() as u8, c.b() as u8, 255];
    let insert_pal = |i: usize| insert_color(palette[i]);

    // let insert_u8 = |s: &[u8]| {
    //   let [r,g,b] = srgb::gamma::linear_from_u8([s[0], s[1], s[2]]);
    //   // img_data.push(&[r as u8,g as u8,b as u8, s[3]]);
    // }

    let mut i = header.offset as usize + 6;
    loop {
      let d = buf[i];
      std::io::Write::write(f.by_ref(), &[d]);
      if d == 0x80 {
        break;
      }
      i += 1;
    }

    let mut i = header.offset as usize + 6;
    loop {
      let d = buf[i];

      if d == 0x00 {
        // end of line (width: 1)
        while x < header.width {
          img_data.push(insert_empty());
          x += 1;
        }
        x = 0;
        i += 1;
        // break;
      } else if d <= 0x7F {
        // set d pixels to next d bytes (width: 1 + d)
        // println!("set {} pixels to next {} bytes", d, d);
        for _ in 0..d as usize {
          i += 1;
          img_data.push(insert_pal(buf[i] as usize));
          x += 1;
        }
        i += 1;
      } else if d == 0x80 {
        // end of data (width: 1)
        while x < header.width {
          img_data.push(insert_empty());
          x += 1;
        }
        break;
      } else if d <= 0xBF {
        // d - 0x80 pixels are transparent (width: 1)
        for _ in 0..(d - 0x80) as u16 {
          img_data.push(insert_empty());
          x += 1;
        }
        i += 1;
      } else if d == 0xC0 {
        // add shadow pixels (width: 2)
        let next = buf[i + 1];
        let mut n = if next % 4 != 0 { next % 4 } else { buf[i + 2] };
        info!("n={}; next={}; next2={};", n, buf[i + 1], buf[i + 2]);
        // if n == 9 {
        //   n = 12;
        // }

        for _ in 0..n {
          img_data.push([0, 0, 0, 128 + 64]);
          x += 1;
        }
        // println!("{}", d);
        if next % 4 != 0 {
          i += 2
        } else {
          i += 3
        }
      } else if d == 0xC1 {
        // buf[i + 1] of same buf[i + 2] colors (width: 3)
        for _ in 0..buf[i + 1] {
          img_data.push(insert_pal(buf[i + 2] as usize));
          x += 1;
        }
        i += 3;
      } else {
        // same color????
        let n = d - 0xC0;
        for _ in 0..n {
          img_data.push(insert_pal(buf[i + 1] as usize));
          x += 1;
        }
        i += 2;
      }
    }

    // while img_data.len() < (header.width * header.height * 4) as usize {
    //   img_data.push(0);
    // }

    return Some((
      *header,
      img_data
        .iter()
        .flat_map(|s| {
          // let [r, g, b] = srgb::gamma::linear_from_u8([s[0], s[1], s[2]]);
          // let [r, g, b] = srgb::xyz_from_linear([r, g, b]);
          // img_data.push(&[r as u8,g as u8,b as u8, s[3]]);
          // [(r * 255.) as u8, (g * 255.) as u8, (b * 255.) as u8, s[3]]
          *s
        })
        .collect(),
    ));
  }

  None
}

fn le_to_u16(buf: &[u8]) -> u16 {
  ((buf[1] as u16) << 8) | buf[0] as u16
}

fn le_to_u32(buf: &[u8]) -> u32 {
  ((buf[3] as u32) << 24) | ((buf[2] as u32) << 16) | ((buf[1] as u32) << 8) | buf[0] as u32
}

fn le_to_i16(buf: &[u8]) -> i16 {
  ((buf[1] as i16) << 8) | buf[0] as i16
}

fn init_pal() -> Vec<Color> {
  let n = pal.len() / 3;
  let mut palette = Vec::with_capacity(n);

  for x in 0..n {
    let i = x * 3;
    palette.push(Color::rgb(
      (pal[i] << 2) as f32,
      (pal[i + 1] << 2) as f32,
      (pal[i + 2] << 2) as f32,
    ));
  }

  palette
}

const pal: [i32; 768] = [
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f,
  0x3f, 0x3c, 0x3c, 0x3c, 0x3a, 0x3a, 0x3a, 0x37, 0x37, 0x37, 0x35, 0x35, 0x35, 0x32, 0x32, 0x32,
  0x30, 0x30, 0x30, 0x2d, 0x2d, 0x2d, 0x2b, 0x2b, 0x2b, 0x29, 0x29, 0x29, 0x26, 0x26, 0x26, 0x24,
  0x24, 0x24, 0x21, 0x21, 0x21, 0x1f, 0x1f, 0x1f, 0x1c, 0x1c, 0x1c, 0x1a, 0x1a, 0x1a, 0x17, 0x17,
  0x17, 0x15, 0x15, 0x15, 0x12, 0x12, 0x12, 0x10, 0x10, 0x10, 0x0e, 0x0e, 0x0e, 0x0b, 0x0b, 0x0b,
  0x09, 0x09, 0x09, 0x06, 0x06, 0x06, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x3f,
  0x3b, 0x37, 0x3c, 0x37, 0x32, 0x3a, 0x34, 0x2e, 0x38, 0x31, 0x2a, 0x36, 0x2e, 0x26, 0x34, 0x2a,
  0x22, 0x32, 0x28, 0x1e, 0x30, 0x25, 0x1b, 0x2e, 0x22, 0x18, 0x2b, 0x1f, 0x15, 0x29, 0x1c, 0x12,
  0x27, 0x1a, 0x0f, 0x25, 0x18, 0x0d, 0x23, 0x15, 0x0b, 0x21, 0x13, 0x08, 0x1f, 0x11, 0x07, 0x1d,
  0x0f, 0x05, 0x1a, 0x0d, 0x04, 0x18, 0x0c, 0x03, 0x16, 0x0a, 0x02, 0x14, 0x09, 0x01, 0x12, 0x07,
  0x01, 0x0f, 0x06, 0x00, 0x0d, 0x05, 0x00, 0x0b, 0x04, 0x00, 0x09, 0x03, 0x00, 0x30, 0x33, 0x3f,
  0x2b, 0x2e, 0x3c, 0x26, 0x2a, 0x3a, 0x22, 0x26, 0x38, 0x1e, 0x22, 0x36, 0x1a, 0x1e, 0x34, 0x16,
  0x1a, 0x31, 0x13, 0x16, 0x2f, 0x10, 0x13, 0x2d, 0x0d, 0x10, 0x2b, 0x0a, 0x0d, 0x29, 0x08, 0x0c,
  0x26, 0x07, 0x0a, 0x24, 0x05, 0x09, 0x22, 0x04, 0x08, 0x20, 0x03, 0x07, 0x1e, 0x02, 0x06, 0x1c,
  0x01, 0x05, 0x19, 0x01, 0x05, 0x17, 0x00, 0x04, 0x15, 0x00, 0x03, 0x13, 0x00, 0x03, 0x11, 0x2b,
  0x38, 0x27, 0x27, 0x35, 0x23, 0x24, 0x33, 0x20, 0x20, 0x30, 0x1c, 0x1d, 0x2e, 0x19, 0x1a, 0x2c,
  0x17, 0x17, 0x29, 0x14, 0x14, 0x27, 0x11, 0x12, 0x24, 0x0f, 0x0f, 0x22, 0x0c, 0x0d, 0x1f, 0x0a,
  0x0b, 0x1d, 0x09, 0x09, 0x1b, 0x07, 0x08, 0x19, 0x06, 0x06, 0x17, 0x05, 0x05, 0x15, 0x03, 0x03,
  0x13, 0x02, 0x02, 0x10, 0x01, 0x01, 0x0e, 0x01, 0x01, 0x0c, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x08,
  0x00, 0x00, 0x06, 0x00, 0x3f, 0x3d, 0x34, 0x3e, 0x3a, 0x2b, 0x3d, 0x38, 0x23, 0x3c, 0x37, 0x1b,
  0x3b, 0x35, 0x14, 0x3a, 0x33, 0x0d, 0x39, 0x32, 0x05, 0x38, 0x31, 0x00, 0x36, 0x2f, 0x08, 0x34,
  0x2c, 0x07, 0x32, 0x28, 0x06, 0x2f, 0x26, 0x06, 0x2d, 0x23, 0x06, 0x2a, 0x1f, 0x05, 0x27, 0x1c,
  0x04, 0x25, 0x19, 0x03, 0x22, 0x16, 0x03, 0x1f, 0x13, 0x02, 0x1d, 0x11, 0x02, 0x1a, 0x0f, 0x00,
  0x18, 0x0c, 0x00, 0x15, 0x0a, 0x00, 0x13, 0x08, 0x00, 0x39, 0x33, 0x3e, 0x36, 0x2f, 0x3b, 0x32,
  0x2a, 0x39, 0x30, 0x27, 0x36, 0x2d, 0x23, 0x34, 0x2a, 0x1f, 0x31, 0x27, 0x1c, 0x2f, 0x24, 0x19,
  0x2d, 0x21, 0x16, 0x2a, 0x1e, 0x13, 0x28, 0x1c, 0x11, 0x25, 0x19, 0x0e, 0x23, 0x17, 0x0c, 0x20,
  0x14, 0x0a, 0x1e, 0x12, 0x08, 0x1b, 0x10, 0x06, 0x19, 0x0e, 0x05, 0x17, 0x0b, 0x02, 0x14, 0x08,
  0x01, 0x11, 0x06, 0x00, 0x0e, 0x04, 0x00, 0x0b, 0x2d, 0x3d, 0x3f, 0x2a, 0x3a, 0x3c, 0x28, 0x38,
  0x3a, 0x25, 0x36, 0x38, 0x22, 0x33, 0x35, 0x20, 0x31, 0x33, 0x1e, 0x2e, 0x31, 0x1c, 0x2c, 0x2f,
  0x19, 0x2a, 0x2c, 0x17, 0x27, 0x2a, 0x16, 0x25, 0x28, 0x14, 0x23, 0x25, 0x12, 0x20, 0x23, 0x10,
  0x1d, 0x20, 0x0e, 0x1a, 0x1d, 0x0c, 0x18, 0x1b, 0x0a, 0x15, 0x18, 0x08, 0x13, 0x16, 0x07, 0x10,
  0x13, 0x05, 0x0e, 0x10, 0x04, 0x0b, 0x0e, 0x03, 0x09, 0x0b, 0x02, 0x07, 0x09, 0x3f, 0x39, 0x39,
  0x3d, 0x34, 0x34, 0x3c, 0x2f, 0x2f, 0x3a, 0x2b, 0x2b, 0x39, 0x27, 0x27, 0x37, 0x23, 0x23, 0x36,
  0x1f, 0x1f, 0x34, 0x1b, 0x1b, 0x33, 0x17, 0x17, 0x31, 0x14, 0x14, 0x30, 0x11, 0x11, 0x2f, 0x0e,
  0x0e, 0x2e, 0x0b, 0x0b, 0x2d, 0x09, 0x09, 0x2a, 0x08, 0x08, 0x27, 0x06, 0x06, 0x24, 0x04, 0x04,
  0x21, 0x03, 0x03, 0x1e, 0x02, 0x02, 0x1b, 0x01, 0x01, 0x18, 0x00, 0x00, 0x15, 0x00, 0x00, 0x12,
  0x00, 0x00, 0x3f, 0x39, 0x27, 0x3e, 0x36, 0x23, 0x3d, 0x34, 0x1f, 0x3c, 0x31, 0x1c, 0x3b, 0x2e,
  0x18, 0x3a, 0x2b, 0x14, 0x39, 0x28, 0x11, 0x38, 0x24, 0x0e, 0x38, 0x21, 0x0b, 0x33, 0x1d, 0x08,
  0x2e, 0x19, 0x06, 0x29, 0x16, 0x04, 0x25, 0x12, 0x02, 0x20, 0x0f, 0x01, 0x1b, 0x0c, 0x00, 0x17,
  0x0a, 0x00, 0x3f, 0x16, 0x03, 0x37, 0x0d, 0x01, 0x30, 0x05, 0x00, 0x29, 0x00, 0x00, 0x3f, 0x3f,
  0x00, 0x3f, 0x33, 0x00, 0x30, 0x23, 0x00, 0x23, 0x12, 0x00, 0x29, 0x34, 0x00, 0x25, 0x2f, 0x00,
  0x21, 0x2b, 0x00, 0x1e, 0x27, 0x01, 0x1a, 0x23, 0x01, 0x17, 0x1e, 0x01, 0x13, 0x1a, 0x01, 0x10,
  0x16, 0x01, 0x0d, 0x12, 0x01, 0x0a, 0x1e, 0x34, 0x06, 0x1a, 0x31, 0x01, 0x12, 0x2d, 0x00, 0x0e,
  0x2b, 0x03, 0x15, 0x2f, 0x00, 0x0e, 0x2b, 0x00, 0x10, 0x2d, 0x21, 0x38, 0x3f, 0x00, 0x26, 0x3f,
  0x00, 0x14, 0x39, 0x00, 0x00, 0x29, 0x23, 0x23, 0x2f, 0x1c, 0x1c, 0x27, 0x15, 0x15, 0x1f, 0x0f,
  0x0f, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
